reviews:
  sequence_diagrams: false
  poem: false
  #...
  path_instructions:
    - path: "**/*.*"
      instructions: |
        Проверь код и убедись, что:
        - Переменные, методы и классы именованы близко к человеческому языку, с соблюдением лексических правил
        - Названия функций и методов начинаются с глаголов, отражающих действие
        - Названия булевых функций начинаются с is (является) или has (имеет)
        - Если создаём единственный инстанс класса, называем его по имени класса
        - Если инстансов несколько, их имена должны отражать роль каждого
        - В одном контексте не используем синонимы для одинаковых вещей
        - Код должен читаться как английское предложение (if variable equals value)
        - Явно прописываем аргументы методов, не упаковываем их в массив/DTO, если это не требуется
        - Сохраняем единое именование переменных по всей цепочке (БД → модель → DTO → контроллер → View)
    - path: "resources/**/**/**/*.{js,vue}"
      instructions: |
        Стндарты фронтенд-кода:
        - В SFC-компонентах должен быть такой порядок блоков: <template>, затем <script> и после него <style>. Стили инкапсулируем внутри родительского класса, используем SASS-ёлочку
        - Если код может быть непонятен, пишем комментарий
        - Цвета берём только из переменных, новые не добавляем
        - Стили инкапсулируем через классы блоков, не используем scoped / module.
        - Убираем console.log и отладочный код
        - Не оставляем закомментированные фрагменты кода
        - Удаляем неиспользуемые переменные, пропсы, методы и т.д.
        - Следуем БЭМ:
            - Блоки именуем как s-blockname (без дефисов, чисел и подчёркиваний)
            - Элементы блока — s-blockname-element, s-blockname-element-subelement
            - Модификаторы — layout_ver (до _ — характеристика, после — её значение). Самые частые модификаторы упрощаем до одного слова
            - Атомарные UI-элементы (.s-button, .s-table, .s-alert) не превращаем в элементы блока, а вставляем как отдельные блоки.
            - Используем единый шаблон разметки страницы:
                #app.s-app
                  header.s-header
                    .s-subheader — может быть несколько
                      .s-subheader-h
                  .s-main
                    .s-section — может быть несколько
                      .s-section-h
                        .s-content
                        aside.s-sidebar
                  footer.s-footer
                    .s-subfooter — может быть несколько
                      .s-subfooter-h
    - path: "app/**/**/**/*.php"
      instructions: |
        Проверь код и убедись, что:
        - Код соответствует стандартам PSR-12 и Laravel
        - Методам даны понятные названия
        - Комментарии на русском
        - У каждого класса есть описание
        - Формат нестандартных атрибутов (например, ассоциативных массивов) описан
        - Мы не создаем избыточные геттеры/сеттеры атрибутов класса
        - Нет лишних геттеров/сеттеров, если только для получения/установки не требуется дополнительных действий
        - Транзакции БД используем только при угрозе нарушения консистентности данных
        - В контроллерах применяем Dependency Injection и сразу получаем объект по ID из роута
        - Для CRUD используем стандартные методы моделей, а нетиповую логику выносим в модель (принцип «тонких контроллеров»)
        - Переменные окружения храним в .env, но используем через конфиг (из-за кеширования на продакшене)
        - В контроллере явно указываем передаваемые в шаблон поля модели, не используя Resource-классы (они для REST API)
        - Контроллеры должны быть «тонкими», а модели — «толстыми». Логика, связанная с моделью, должна быть внутри неё, чтобы код был переиспользуемым
        - Валидацию выносим в Form Request.
